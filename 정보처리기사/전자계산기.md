### 인터럽트의 종류 및 발생원인
- 인터럽트 플래그를 0으로 하면 인터럽트 발생을 방지할 수 있다
- 종류
    - 외부 인터럽트 (CPU의 하드웨어 신호에 의해 발생)
        - 전원이상 인터럽트
        - 기계착오 인터럽트 : CPU의 기능 이상 오류
        - 외부신호 인터럽트 : 타이머에 의해 타임슬라이스를 알리는 경우, 키보드를 누르는 경우
        - 입출력 인터럽트 : 입출력장치가 데이터의 전송이 끝났음을 알리는 경우
    - 내부 인터럽트 (CPU의 하드웨어 신호에 의해 발생)
        - 잘못된 명령이나 데이터를 사용할 때 발생. 트랩
        - 프로그램 검사 인터럽트
            - 0으로 나누기
            - overflow, underflow
            - 명령어를 잘못사용
    - 소프트웨어 인터럽트 (명령어의 수행에 의해 발생)
        - 명령의 요청
        - SVC(Supervisor Call) 인터럽트 : 감시프로그램 호출. 사용자가 svc 명령을 호출, 복잡한 입출력
    - operator의 의도적인 조작
    -기억공간 내 허용되지 않는 곳에서의 접근 시도
- PSW(Program Status Word) : CPU의 상태를 나타내는 정보를 가지고, 독립된 레지스터로 구성된다.
- 인터럽트 우선순위 판별 방법
    - 소프트웨어적인 방법 : Polling
    - 하드웨어적인 방법 : Vectored Interrupt
        - 직렬 우선순위 부여 방식 : 데이지 체인 : 인터럽트가 발생하는 모든 장치를 한 개의 회선에 직렬로 연결.
        - 이동안 CPU는 다른 작업을 계속 수행
### 폴링
- 인터럽트의 우선순위 판별 방법. 요청 신호 플래그를 차례로 검사하여 판별
- 소프트웨어 방식


### 주소 지정방식의 종류
- 암시적 주소 지정방식(Implied Mode)
    - 명령실행에 필요한 **데이터의 위치를 지정하지 않고** 누산기나 스택의 데이터를 묵시적으로 지정하여 사용.
    - 오퍼랜드가 없는 명령.
    - 오퍼랜드가 하나인 명령 PUSH R1 

- 즉시적 주소 지정방식(Immediate Mode)
    - **명령어 자체**에 오퍼랜드 실제 데이터를 내포하는 방식
    - CPU에서 곧바로 액세스 하여 실행속도 빠름.
    - 명령어의 길이에 영향받음. 표현할 수 있는 데이터의 값의 범위가 제한적

- 직접 주소 지정방식(Direct Mode) 
    - Operand(명령어의 주소부)가 사용할 자료의 번지를 표현
    - 실제 데이터가 기억된 기억장소에 직접 사상 가능
    - 실제 데이터의 유효 주소를 적어서 주소 길이에 제약 받음
    - 명령어의 주소부를 유효 주소로 이용

- 간접 주소 지정방식(Indirect Mode)
    - 명렁어에 나타낼 주소가 길 때, 명렁어 내에서 데이터를 지정하기 위해 할당된 비트수로 나타낼 수 없을만큼 길때 사용

- 계산에 의한 주소지정 방식 ( 약식 주소 )
    - Operand와 특정 레지스터의 값이 더해져 유효주소 계싼
    - 일반적인 주소 지정방식에 비해 적은 수의 비트를 사용하고, 레지스터 지정 필드없이 레지스터를 지정하여 사용


### 플립플롭
- 플립플롭은 전원이 공급되고 있는 한 상태의 변화를 위한 신호가 발생할 때까지 현재의 상태를 그대로 유지하는 논리회로
- 쌍안정 논리회로
- 플립플롭 1개가 1bit를 구성하는 2진 셀이 듀ㅚㄴ다
- 반도체 기억장치에서 2진수 1자리 값을 기억하는 메모리 소자
- 플립플롭은 레지스터를 구성하는 기본 논리회로이다
- 기본적인 플립플롭은 2개의 NAND 또는 NOR 게이트를 이용하여 구성한다

- RS : 플립플롭의 기본. S +R 무조건 0또는 1의 값을 기억시키기 위해 사용
- JK : R=S=1일때 동작되지 않는 결점 보완. 모든 플립플롭의 기능을 포함
- D : RS FF 의 R선에서 인버터를 추가하여 S선과 하나로 묶어서 구성. 입력하는 값을 그대로 저장
- T : JK FF 의 두 입력선을 묶어서 하나로 구성
- 마스터 슬레이브 ( M / S ) : 출력측의 일부가 입력측에 궤환 되어 유발되는 레이스 현상을 없애기 위해 고안

### 메모리 인터리빙
- CPU가 각 모듈로 전송할 주소를 교대로 분산 배치한 후 차례대로 전송하여 여러 모듈을 병행 접근하는 기법
- CPU와 기억장치 사이에 실질적인 대역폭을 늘리기 위한 방법
- 동시에 복수의 메모리에 접근하여 메모리 접근속도를 높임
- 기억장치에 대한 접근 속도를 증가시킬 수 있음
- 중앙처리장치의 쉬는시간을 줄 일 수 있고, 단위 시간당 수행할 수 있는 명령어의 수를 증가시킬 수 있다
- 캐시 기억장치, 규속 DMA 전송등에 사용

### 인스트럭션 세트의 효율성을 높이기 위한 고려사항
- 기억 공간, 사용 빈도, 주소지정 방식, 주기억장치 밴드폭

### Cycle Streal
- 데이터 채널(DMA제어기) 와 CPU가 주기억장치를 동시에 엑세스 할 때 우선순우ㅟ를 데이터 채널에게 주는 방식
- 한 번에 한 데이터 워드를 전송하고 버스의 제어를 CPU에게 돌려준다
- CPU가 어떤 명령과 다음 명령을 수행하는 사이를 이용하여 하나의 데이터 워드를 직접 전송하는 DMA방식
- 사이클이란, 주기억 장치에 CPU가 접근하는 한 사이클
- 이를 훔쳐오므로 한 주기가 정지되는 것이다

### 중앙처리장치의 핵심 4단계
1. 인출단계 (Fetch Cycle)
    - 주기억장치에서 중앙처리장치의 명령 레지스터로 가져와 해독
    - 1Cycle 명령 -> 다시 fetch
    - 0 직접주소 -> Excute
    - 1 간접주소 -> Indirect
2. 실행단계 (Execute Cycle)
    - 해석한 명령 실행
    - 플래그 레지스터의 상태변화를 검사 인터럽트로 갈건지를 판단
    - 인터럽트가 없으면 fetch로
3. 간접단계 (Indirect Cycle)
    - 간접주소인 경우
    - 오퍼랜드의 주소를 읽는다.
    - 유효주소를 계싼하기위해 다시 indirect
4. 인터럽트 단계 (Interrupt Cycle)
    - 인터럽트 복귀주소(PC)저장
    - 제어순서를 인터럽트 처리 프로그램의 첫 번째 명령으로 옮김
    - 인터럽트 마친 후에는 fetch로
    - 서브루틴의 호출

### ADD, LDA, STA, BSA

### 병렬 처리 기법 : Pipeline Processor, Vector Processor, Array Processor, Data flow COmputer

### 연산자 (Operation Code)
- 함수 연산 : ADD, SUB, MUL, DIV, NOT, AND, OR, ROTATE, COMPLEMENT, CLEAR, ROL, CLC
- 자료 전달 : LOAD, STORE, MOVE, PUSH, POP
- 제어 기능 : GOTO, JUMP, IF, SPA, SNA, SZA, CALL, RETURN
- 입출력 기능 

### 논리회로
- 조합 논리회로 : qksrktksrl, wjsrktksrl, emdemd, 입력과 출력. 기억 기능이 없다. 멀티플렉서. 
- 순서 논리회로 : 플립플롭, 카운터, 레지스터, RAM, CPU. 현재 상태에 의해 출력이 결정됨

### 명령어 처리
- 0주소 명령어 : 스택
- 1주소 명령어 : 누산기
- 2 3주소 명령어 : GPR 범용 레지스터

### 명령어의 구성
- Operation Code (연산부), Mode, Operand (자료부)
- Operand(주소 자료 부 ) : 기억장치의 주소, 레지스터 번호, 사용할 데이터 

### 마이크로 오퍼레이션
- 인스트럭션 명령어를 수행하기 위해 CPU내의 레지스터와 플래그가 의미있는 상태 변환을 하도록 하는 동작
- 레지스터에 저장된 '데이터;에 의해 이루어지는 동작
- 마이크로 오퍼레이션은 하나의 클록 펄스 동안 실행되는 기본 동작

### Stack의 용도
- 함수 호출의 순서 제어
- 인터럽트의 복귀 주소
- 후위표기법 산술식을 연산
- 0주소 지정방식
- 컴파일러를 이용한 언어 번역

### 레지스터
- 중앙처리장치의 구성요소. 플립플롭이나 래치들을 병렬로 연결하여 구성하는 것.
- 프로그램 카운터, 프로그램 계수기 : 다음번에 실행할 명령어의 번지를 저장
- 상태 레지스터, PSWR, 플래그레지스터 : 시스템 내부의 순간순간의 상태가 기록 : 오버플로 언더플로 자리올림 계산상태 인터럽트
- 인덱스 레지스터 : 주소의 변경, 서브루틴 연결, 반복, 연산의 횟수, 사용자가 내용을 변경할 수 있음

### 인스트럭션(명령어) 설계시 고려사항
- 기억 공간
- 사용 빈도
- 주소 지정 방식
- 주기억장치 밴드폭
- 데이터 구조
- 연산자의 수와 종류

### 운영체제의 운용 기법 및 발달과정
- 일괄처리 시스템 : 일정량 또는 일정 기간 동안 데이터를 모아서 한꺼번에 처리하는 방식
- 다중프로그래밍 : 하나의 CPU와 주기억장치를 이용해 여러개의 프로그램을 동시에 처리하는 방식. 하나의 주기억장치에 2개이상의 프로그램, 대화하면서 처리
- 다중처리시스템 : 여러개의 CPU와 하나의 주기억장치로 여러개의 프로그램을 동시에 처리
- 시분할 시스템 : 라운드로빈 대화식처리

### DMA의 데이터 전송 절차
1. 버스 사용 요구
2. 버스 사용 허가
3. 데이터 전송
4. 인터럽트

### 가상 기억 장치 
- 보조기억장치의 일부를 주기억장치처럼 사용하는 것. 용량보다 더 큰 프로그램을 실행하기 위해 사용. 가상기억장치의 주소를 주 기억장치의 주소로 바꾸는 주소 변환작업(매핑)이 필요
- 설계가 복잡, 주소 변환을 위한 테이블을 사용하므로 기억장소를 낭비할 수 있음

- 페이징 기법 : 가상기억장치의 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후, 내부 단편화 발생. 페이지 맵 테이블 필요
- 세그멘테이션 기법 : 가상기억장치의 프로그램을 논리적 단위로 나눈 후 주기억장치에 적재. 논리적인 크기로 프로그램을 나눈 단위를 세그먼트. 고유한 이름을 가짐. 기억장치 보호키 필요. 외부단편화 발생

### 페이지 부재
- 페이지가 없는 거

### 페이지 교체 알고리즘
- 페이지 부재 발생시, 가상 기억장치의 필요한 페이지를 주기억장치에 적재.
- OPT (OptimalReplacement) : 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체. 실현 가능성 희박 이걸 어케알음;;
- FIFO
- LRU (Least Recentely Used) : 최근에 가장 오랫동안 사용하지 않는 페이지를 고체
- LFU (Least Frequently Used) : 사용빈도가 가장 적은 페이지 교체
- NUR (Not Used Recently) : 최근에 사용하지 않은 페이지. 
- SCR (Second Chance Replacement) : FIFO 보완


### 입 출력 제어 방식
- Programmed I/O : 인아웃으르위해 씨피유가 플래그(레지스터)를 계속 조사
- Interrupt I/O : 인터페이스가 컴퓨터에게 알려 인아웃 이루어짐
- DMA (Cycle Steal)
- Channel : I/O 명령어를 I/O 프로세서에게 수행토록 하여 cpu 관여없이 주기억장치와 입출력장치 사이에서 입출력을 제어
    - Selector Channel : 고속 입출력장치 ( 자기디스크, 자기테이프, 자기드럼)
    - Multiplexer Channel : 저속 입출력 장치 여러개를 동시에 제어하는 채널
    - Block Multiplexer Channel : 고속 입출력장치 여러개를 제어




